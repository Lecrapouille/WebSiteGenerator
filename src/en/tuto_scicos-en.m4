dnl -*- html -*- Syntaxic coloration for Emacs
divert(DIVERT_HEADER_CODE)

DEF_TITLE(Logiciel de modélisation et de simulation Scilab/Scicos)
DEF_KEYWORDS()
DEF_DESCRIPTION()
MENU_ACTIF(MENU_TUTO)

divert(DIVERT_NAVIGATION_CODE)

dnl ICON_NEW STRONG(Page en cours de rédaction).

LEFT_MENU(
LEFT_RUBRIC(Découverte de Scilab/Scicos,
Présentation,#intro,
Où apprendre à l'utiliser ?,#howto,
Une astuce importante,#astuce)

LEFT_RUBRIC(Scicos temps réel,
Scicos temps réel,#rt)

LEFT_RUBRIC(Créer des blocs,
Contexte,#con1,
La fonction d'interface,#interface,
La fonction de simulation,#simulation,
Quelques fonctions C Scilab utiles,#other)

LEFT_RUBRIC(Compilation,
Deux méthodes possibles,#con2,
Méthode 1 (Makefile),#met1,
Méthode 2 (builder),#met2)

LEFT_RUBRIC(Chargement,
Méthode 1 (Makefile),#chargmet1,
Méthode 2 (builder),#chargmet2)

LEFT_RUBRIC(Utilisation,
Nouveau projet,#nouv,
Charger automatiquement mes blibliothèques partagées,#scilabstar,
Dernières remarques,#conclu)

BANNIERES)

divert(DIVERT_FOOTER_CODE)

divert(DIVERT_BODY_CODE)

SECTION(Discovery of Scilab/Scicos software)
SUBSECTION(ICON_EYES[]Presentation,intro)

<p>SCILAB is a free software for scientific computation. This is an
   langage interpretor manipulating dynamical typed objects. It
   includes numerous functions specialized in numerical computations
   organized as libraries or tool boxes and covers domains like
   simulation, optimization, signal processing and regulation of
   dynamical systems.</p>

<p>One of the most important Scilab's tool box is SCICOS which is a
   simulator of hybrid systems with a graphical GUI manipulating block
   diagrams allowing to design dynamical systems with continous time,
   discrete time and discrete events.</p>

SUBSECTION(ICON_READ[]Where to learn how to use Scilab and Scicos ?,howto)
<p>We can find on the SAPHIR site, articles from the Linux Magazine
   explaining how to use the Scilab and Scicos GUI, how to create
   programs, how to run simulation, ... This document try to explain
   how to create new Scicos blocks calling C code in the aim to
   increase possibilities of Scicos in the gestion of real time
   embedded applications. For example, we can think to add some
   input/output blocks like FireWire cameras, USB joysticks, serial
   or USB links, ... that allows to set Scicos in regulation loop and
   communicate with an acquisition card. The project
   MYLINK(helico_intro,four-rotor heads helicopter) use this mean.</p>

SUBSECTION(ICON_READ[]An great trick,astuce)

<p>Scilab znd Scicos cannot run at the same time. We have to choose
   one or the other. When you work with Scilab, you can call Scicos in
   the Scilab prompt by typing STRONG(scicos;). But once Scicos is
   launched, the Scilab is no more able. To return in the prompt, you
   have to click in the STRONG(Calc) button of the STRONG(Tools) menu
   from the Scicos window. Scicos is no more able. You have to type
   the command STRONG(return) in the prompt.</p>

SECTION(Real time simulation with Scicos)
SUBSECTION(ICON_GEAR[]The Real time in Scicos,rt)
<p>One of the difficulties met during the MYLINK(helico_intro,H4H)
   project was to determine exactly the Scicos execution speed in the
   aim to determine the real sampling frequency of signals coming from
   the inertial sensors of the helicopter.</p>

<p>A Scicos missknown functionality is the possibility to run in real
   time a simulation by putting the value of the field STRONG(Real
   Time Scaling) to 1 (see figure below) in the STRONG(Simulate) menu.
   User has to take care about the definition of the following points:</p>

LISTE(A frequency is in fact a pulsation. For example to generate a
     1Hz sinusoid with the STRONG(Sinusoid Generator) block, the user
     has to set the field STRONG(Frequency) with the value 2 &pi;.,

     The period of events generated by the clock where the cycle of a
     square signal from the block STRONG(square wave generator) needs
     two events to be generated.)

<p>So, one second in Scicos matches to one real second. Sometimes
   Scicos is no more avalable to keep the imposed rythm due to a
   too fast frequency in the clock or a graphical buffer too small or
   by block calling Scilab code (STRONG(Sciblock) block) that Scicos
   has to interpretate. STRONG(Sciblock) blocks has to be
   forgotten. Use instead STRONG(Mathematical Expression) blocks or
   STRONG(C block) that are faster.</p>

PICTURE(tuto/scicos/scicos_rt.jpg,Propriety of the simulation.)

<!-- <p>Ceci entraîne des problèmes de fréquence d'échantillonnage. Le
   théorème de Shannon dit que la fréquence d'échantillonnage doit
   être plus du double de la fréquence maximale du signal pour le
   restituer correctement.</p>-->

<p>Sampling speeds have been obtained with a 19200 bauds serial
   link:</p>
   LISTE(20 Hz with an 933 MHz G4 iBook and an USB/serial link
   converter (that slow down the speed)., 50 Hz on a 1.2 GHz PC with a
   Ubuntu and a recompiled kernel to 1KHz.)

CENTER(CAPTION(helico/schemas/10oct_50Hz_115200bds.jpg))

<p>These values strongly depend on your CPU, your operating system,
  others running processes, ... You have to make your own experience
  and mesures. The following picture shows a 50 Hz real time
  communication between a dsPIC and Scicos with a 115200 bauds serial
  link. Messages have a size of 4 and 12 bytes.</p>

SECTION(Create new Scicos blocks)
SUBSECTION(ICON_EYES[]Context,con1)

<p>Predifined blocks in Scicos palets allow to build lot of and
   various dynamic systems but in some cases, we have to use a
   functionality that Scicos is not able to offer. We can add this by
   creating shared libraries, compiled from C files addes loaded in
   Scilab. A shared library has the extension *.so in Linux, *.dylib
   on Mac OS X, *.dll on Windows.</p>

<p>STRONG(WARNING:) This method is an alternative from STRONG(C Block
   2). The C blocks are very powerful for small C functions because it
   is eable to write directly code in the Scicos GUI. But these blocks
   become hard to use if the size of the code becomes huge. In
   addition it seems that they are limited to one file, and cannot
   use libraries.</p>

<p>For example, here they are three Scicos application using new
   blocks.</p>

LISTE(The first example of application is the use of a FireWire camera
      (aka for IEEE 1394) called Fire-i and where images are stored in
      ppm files. The LIBDC1394 library has been used. The block works
      for Linux and Mac OS X LINK(stages_download-LANG.html#down2,here
      to dwonoad).,The second example is the reception of data from an
      USB joystick thanks the Linux
      API. LINK(helico_download-fr.html#prog,here to download).,The
      third example is a block that can read and write messages on the
      serial port/link.)

TABLEAU(3,PICTURE(tuto/scicos/camera2.jpg,Application with a camera.),
PICTURE(tuto/scicos/camera1.jpg, Only real geeks will understand why !),
PICTURE(tuto/scicos/firei.jpg,Fire-i camera used.),
PICTURE(tuto/scicos/joy_block.jpg,Application with a joystick.),
PICTURE(tuto/scicos/joy_plot.jpg,Plot of the joystick data.),
PICTURE(tuto/scicos/ST90.jpg,ST90 joystick used.))

<p>The following interface functions and simulation functions used in
   the next of this document served of models. They can be used and be
   easily modified for other applications/projects. As big example, we
   are going to create a Scicos block able to get pictures from a
   FireWire camer thanks libraires LIBRAW1394 and LIBDC1394.</p>

<p>In a general way, blocks can be coded by several ways (Scilab, C,
   Fortran), but in all cases, Scicos needs two types of functions:</p>

   LISTE(An interface function[,] written in Scilab[,] for generate
   the block window in the Scicos GUI., A simulation function
   achieving the dynamic behavior of the block. In the following
   example[,] it will be written in C.)

SUBSECTION(ICON_GEAR[]The interface function,interface)
<p>The interface function of a block established not only its geometry
   its color, its number and size of input/output ports, etc., but
   also its initial states and its parameters. This function generates
   a window popup that permits to the user to modify the simulation
   parameters. This windows appears when, we double click on the block.</p>

<p>Interface functions have the *.sci extension and follow the
   following model:</p>

CODE
// File: CAMERA_FIREWIRE.sci

function [[x,y,typ]]=CAMERA_FIREWIRE(job,arg1,arg2)
x=[[]];y=[[]];typ=[[]]
select job

case 'plot' then
  standard_draw(arg1)
case 'getinputs' then
  [[x,y,typ]]=standard_inputs(o)
case 'getoutputs' then
  [[x,y,typ]]=standard_outputs(o)
case 'getorigin' then
  [[x,y]]=standard_origin(arg1)

case 'set' then
  x=arg1;
  graphics=arg1.graphics;
  exprs=graphics.exprs;
  model=arg1.model;
  while %t do
    [[ok,height,width,exprs]]=getvalue(..
        [['FireWire Camera (IEEE 1394)';
         '';
         'Take a RGB picture as a 3 x height x width sized vector']],..
        [['Height';
        'Width']],..
         list('vec',1,'vec',1),exprs)
    if ~ok then break,end //user cancel modification
    graphics.exprs=exprs;
    if ok then
        model.ipar=[[height,width]]
        graphics.exprs=exprs;
        x.graphics=graphics;
        model.out = 3 * height * width;
        x.model=model;
        break
    end
  end

case 'define' then
  height = 240
  width  = 320
  model  = scicos_model()
  model.sim = list('scicos_camerafirewire',4)
  model.evtin = 1;
  model.out = [[3 * 240 * 320]];
  model.ipar=[[height,width]]
  model.blocktype='d'
  model.dep_ut=[[%f %t]]
  exprs=[[string(height); string(width)]]
  gr_i=[['txt=[''Camera'';''FireWire''];';
    'xstringb(orig(1),orig(2),txt,sz(1),sz(2),''fill'')']]
  x=standard_define([[4 2]],model,exprs,gr_i)
end
endfunction
ENDCODE

<p>Let's explain what this code do.</p>
<p>The value of the state variable STRONG(job) is managed  by
  Scicos. Cases STRONG(define) and STRONG(set) must be adapted by the
  developer. Cases STRONG(plot), STRONG(getinputs) and
   STRONG(getoutputs) have not been modified for our block.</p>

<p>STRONG(define) define initial values of the simulation. STRONG(set)
   managed the popup window that allows these paramaters. In our
   example, we have added parameters STRONG(height) and
   STRONG(width) that are vectors of size 1 (aka scalar). They defines
   the picture size. Obviously, we can add others parameters as
   freshness frequency, type of picture (RGB, YUV, ...) and so long.</p>

<p>Let's remark taht STRONG(exprs) is a varaible used by Scicos. We
   have to keep it. Do not remove it ! Finaly, there are other data
   types than vec: STRONG(string) ...</p>

CODE
  while %t do
    [[ok,height,width,exprs]]=getvalue(..

        STRONG(// Title of the popup window)
        [['Camera FireWire (IEEE 1394)';
         '';
         'Take a RGB picture as a 3 x height x width sized vector']],..

        STRONG(// Fields of the popup window)
        [['Height';
        'Width']],..

        STRONG(// Parameter types)
        list('vec',1,'vec',1),exprs)
ENDCODE

 <p>Variables STRONG(graphics) and STRONG(model) are
   structures represented as list form. STRONG(graphics)
   contains informations about block aspect, as its size, its
   location, ... and STRONG(model) have informations for the
   simulation like the name of the simulation function and its type,
   its number and sizes of inpu/output ports, states of values,
   parameters, etc.</p>

<p>In the case of STRONG(define), we create:</p>

LISTE(Two parameters STRONG(height) and STRONG(width) that define the
      default size of the picture.,

      STRONG(model.out) is the output port whick is a vector of size 3
      x 240 x 320. A block can have several outputs of different sizes
      (so, we have a vector of a vector of values). If we want to have
      at least two outputs we use square brackets.,

      STRONG(model.in) we have no entries because we are defining a
      camera so an actuator[,] so model.in is not present in the code
      because it is explicit. If we absolutely want put it[,] we have
      to take care not to affect it to the 0 value[,] but instead, to
      set it to an empty array [[ ]] else this means that we desire a
      zero-sized entry which doesn't mean a lack of entry.,

      STRONG(model.evtin) indicates that we have a clock event. The
      picture frame rate of the camera is given by this clock
      event. Even if the inner camera frame rate has been set to 30
      FPS[,] picture will be sampled to this period.,

      STRONG(model.blocktype) 'd' indicates gives a discret
      signal. 'c' is used for continuous signal.,

      The element STRONG(%f %t) indicates that this block does not
      contains direct dependency between input-output[,] but it is time
      dependant.,

       STRONG(model.sim) shall match to the name of the C simulation function.)

<p>The popup windows created will have the following
   LINK(tuto/scicos/camera1.jpg, form).</p>


SUBSECTION(ICON_GEAR[]The simulation function,simulation)

<p>The model of the simulation function in C language is less complex
   than the interface function. Indeed, its definition is the follow
   STRONG(void f(scicos_block*, int)). It does the following tasks,
   depending on the value of the parameter STRONG(flag) :</p>

LISTE(STRONG(Initialisation:) Allows to initialize initial states[,]
      allocate memory[,] open file descriptors[,] etc. Scicos enters
      in this mode once and at the begining of each new simulation. In
      the case where our camera block[,] we will FireWire port[,]
      detect plugged cameras and initialized the picture format[,]
      frame rate[,] etc.,

      STRONG(Ending:) Scicos enters in this mode once and only when
      the simulation ends in the aim to free memory[,] file
      descriptors[,] etc. Programmers have not to forget to write
      clean code else Scicos may crash in next initialisation phases
      cause of a large number of opened file descriptors or not enough
      memory. In our case[,] we have to close FireWire communication
      port to the camera[,] free picture buffers. STRONG(BE CAREFUL !)
      When user press the STRONG(stop) button from the Scicos GUI[,]
      the simulation is only in a stand by mode and has not
      ended. That means this phase is not called and so neither memory
      freed nor files closed. They will when the user will press the
      STRONG(end) button or the STRONG(restart) button from
      STRONG(Simulate) and STRONG(Run) menus.,

      STRONG(Outputs computation:) The function computes its outputs
      from the values of its inputs and states (memories). Programmers
      can do what they want in this phase at the exception of creating
      infinite loops that will complety freezed Scicos. If done, it
      will not be possible to take control of the GUI. We will have to
      kill Scilab with a console.,

      Other cases exist as: update states[,] date computations of
      output events[,] computation of the derivative of the continuous
      state[,] ...)

CODE
/* File: scicos_camera_firewire.c */

#include &lt;scicos/scicos_block.h&gt;

void            scicos_camera_firewire(scicos_block *block, int flag)
{
  switch (flag)
    {
    case INITIALISATION:
      camera_firewire_open();
      break;
    case TERMINAISON:
      camera_firewire_close();
      break;
    case CALCUL_DES_SORTIES:
      camera_firewire_get_new_image(block);
      break;
    default: break;
    }
}
ENDCODE

<p>The STRONG(flag) value is automaticly updated by Scicos. We can
   hide the value of different types of operation by using
   STRONG(define) (even if, currently, Scicos developpers prefer
   using litteral values of STRONG(flag)).</p>

CODE
#define CALCUL_DES_SORTIES      1
#define INITIALISATION          4
#define TERMINAISON             5
ENDCODE


<!--
   <p>On fera attention, au bouton STRONG(stop) du menu Scicos qui ne
   termine pas la simulation, mais la met en ITALIQUE(pause). Par
   conséquent la fonction STRONG(camera_firewire_close) n'est pas
   appelée. Elle le sera que si on clique ensuite sur le bouton
   STRONG(halt) ou STRONG(restart).</p>
-->

<p>We have not talk about the STRONG(scicos_block) structure yet. It
   contains all useful informations about blocks like input/output
   ports, parameters, states. It is defined in the file
   STRONG(&lt;scicos/scicos_block.h&gt;). Significant fields are
   STRONG(outptr) (output ports), STRONG(inptr) (input ports),
   STRONG(ipar) parameters of popup window.</p>

CODE
typedef  struct
{
  int    nevprt; /* binary coding of activation inputs, -1 if internal ly activated */
  voidg  funpt;  /* pointer: pointer to the computational function */
  int    type;   /* type of interfacing function, current type is 4 */
  int    scsptr; /* not used for C interfacing functions */
  int    nz; /* size of the discrete-time state */
  double *z; /* vector of size nz: discrete-time state */
  int    nx; /* size of the continuous-time state */
  double *x; /* vector of size nx: continuous-time state */
  double *xd;  /* vector of size nx: derivative of continuous-time state */
  double *res; /* only used for internal ly implicit blocks. vector of size nx */
  int    nin;  /* number of inputs */
  int    *insz;   /* input sizes */
  double **inptr; /* table of pointers to inputs */
  int    nout;    /* number of outputs */
  int    *outsz;  /* output sizes */
  double **outptr;/* table of pointers to outputs */
  int    nevout;  /* number of activation output ports */
  double *evout;  /* delay times of output activations */
  int    nrpar;   /* number of real parameters */
  double *rpar;   /* real parameters of size nrpar */
  int    nipar;   /* number of integer parameters */
  int    *ipar;   /* integer parameters of size nipar */
  int    ng;   /* number of zero-crossing surfaces */
  double *g;   /* zero-crossing surfaces */
  int    ztyp; /* boolean, true only if block MAY have zero-crossings */
  int    *jroot; /* vector of size ng indicating the presence and direction of crossings */
  char   *label; /* block label */
  void   **work; /* pointer to workspace if al location done by block */
  int    nmode;  /* number of modes */
  int    *mode;  /* mode vector of size nmode */
} scicos_block;
ENDCODE


<p>There it is the computation function for outputs. The code is not
   necessarily optimal in performance term. It is showed as example !</p>

CODE
/* File: scicos_camera_firewire.c or other */

static struct     s_device_firewire device;

void              camera_firewire_get_new_image(scicos_block *block)
{
  int             i;
  static char     img_rgb[[3 * IMAGE_MAX_WIDTH * IMAGE_MAX_HEIGHT]];

  /* Refresh the picture buffer */
  img_rgb = camera_firewire_get_new_image(&amp;device);

  /* Copy the frame buffer in the output port */
  /* block->ipar[[0]] --> popup window parameter: picture height */
  /* block->ipar[[1]] --> popup window parameter: picture width */
  for (i = 0; i &lt; 3 * block->ipar[[0]] * block->ipar[[1]]; ++i)
    block->outptr[[0]][[i]] = image_rgb[[i]];
}
ENDCODE

<p>We write in the single output port STRONG(block->outptr) identified
   by 0. Here, the STRONG(static) word is used to avoid stack overflow
   because it is the storage place of local variables, which are,
   here, quite huge.</p>

SUBSECTION(ICON_GEAR[]Some useful Scilab functions,other)
<p>It can be useful to add the following lines in C files for the
   simulation function.</p>

CODE
#include &lt;machine.h&gt;

extern int  C2F(cvstr)  __PARAMS((integer *,integer *,char *,integer *,unsigned long int));
extern int  cvstr_();
extern void sciprint(char *fmt, ...);
ENDCODE

<p>STRONG(sciprint) acts the same aim than the STRONG(printf) C
   function, except that it prints a message in the Scilab prompt.</p>

<p>A useful function that allows to pick up the content from a string
   coming from the interface function (where the type is
   STRONG(string)) is the STRONG(cvstr) Fortran function. For example
   it is useful if we want to get the name of a device found about the
   popup window (i.g. the serial link name STRONG(/dev/ttyS0)).</p>

CODE
#  define E_SIZE_NAME           0
#  define E_BEGIN_NAME          1

char portname[[64]]; /* Name of the device */
int  job = 1;

F2C(cvstr)(&amp;(block->ipar[[E_SIZE_NAME]]),
           &amp;(block->ipar[[E_BEGIN_NAME]]),
           portname,
           &amp;job,
           strlen(portname));

portname[[block->ipar[E_SIZE_NAME]]] = '\0';
ENDCODE

SECTION(Compilation de la fonction de simulation)

SUBSECTION(ICON_EYES[]Deux méthodes possibles,con2)

<p>Il nous reste à compiler la bibliothèque partagée à partir de
   fichiers C avant de la charger dans Scilab. Pour cela il existe
   deux méthodes : créer son propre Makefile ou bien créer un fichier
   Scilab qui va dire à Scilab comment il doit compiler nos sources.</p>

<p>La deuxième méthode est celle recommandée pour débuter (commencez
   avec un programme simple !). Personellement, j'utilise la première
   méthode parce que je n'ai pas réussi à ajouter mes propres flags de
   compilation.</p>

SUBSECTION(ICON_READ[]Méthode 1 : En crééant son propre Makefile,met1)

<p>Le Makefile suivant permet de créer la shared library pour
   Linux. Les options STRONG(-shared) et STRONG(-fPIC) sont
   spécifiques pour Linux. Pour Mac OS X il faut remplacer
   STRONG(-shared) par STRONG(-dynamiclib -flat_namespace -undefined
   suppress).</p>

CODE
LIBSO=libMaCamera.so

SOURCES= \
        camera_scicos.c \
        fichier2.c \
        fichier3.c

OBJS=$(SOURCES:.c=.o)

all: $(LIBSO)

$(LIBSO): $(OBJS)
        gcc -shared $(OBJS) -o $@

%.o: %.c
        gcc -c -fPIC $&lt; -o $@
ENDCODE

<p>On lance le Makefile et si tout va bien on obtient un fichier
   STRONG(libMaCamera.so).</p>

SUBSECTION(ICON_READ[]Méthode 2 : En se faisant aider par Scilab,met2)

<p>La deuxième méthode consite à créer un fichier scilab qu'on
   appelera STRONG(builder.sce) et qui va dire à Scicos comment créer
   le Makefile et compiler nos sources.</p>

CODE
// Fichier: builder.sce

// Nom des fonctions C qui doivent etre exportees dans les blocs Scicos
comp_fun_lst = [['scicos_camera_firewire']];

// Liste des fichiers C a compiler
c_prog_lst   = [['camera_scicos.c']];

// Leurs equivalents compiles
prog_list    = strsubst(c_prog_lst, '.c', '.o');

// Bibliotheques (*.so, *.dylib) necessaires pour compiler notre code
lib_list     = [['libraw1394','libdc1394_control']];

// Creation du Makefile associe et compilation du code
ilib_for_link(comp_fun_lst, prog_list, lib_list, 'c');
ENDCODE

<p>La variable STRONG(comp_fun_lst) est une liste de chaîne de
   caractères indiquant les noms des fonctions à
   utiliser. STRONG(c_prog_lst) stocke tous les noms des fichiers C à
   compiler. STRONG(prog_list) stocke les noms des fichiers objets
   dont l'extension se termine par o. STRONG(lib_list) stocke les noms
   de librairies partagées nécessaires à la compilation (*.so). Ces
   librairies se trouvent en général dans le répertoire
   STRONG(/usr/lib/) et doivent être partagées.</p>

<p>Pour compiler les fichiers sources, il suffit d'écrire dans le
   prompt de Scilab, les lignes suivantes :</p>

CODE
cd /le/chemin/de/ma/biblio/partagee/;
exec('builder.sce');
ENDCODE

SECTION(Charger la blibliothèque dans Scilab)
SUBSECTION(ICON_READ[]Avec la méthode 1 (Makefile),chargmet1)

<p>Il faut également créer un deuxième fichier
   appelé STRONG(loader.sce) dont le contenu est le suivant.</p>

CODE
// Fichier: loader.sce

mypath=get_absolute_file_path('loader.sce');
link('le/chemin/vers/une/autre/biblio/partage/par/exemple/API/libraw1394/libraw1394.so');
link('le/chemin/vers/une/autre/biblio/partage/par/exemple/API/libdc1394/libdc1394.so');
link(mypath + 'libMaCamera.so', ['scicos_camera_firewire', 'fonction2'], 'c');
ENDCODE

<p>STRONG(mypath) va connaitre le chemin du répertoire où l'on
   travaille. STRONG(link) vont charger dans Scilab des bibliothèques
   partagées utiles à la bonne exécution de notre bloc. Enfin on
   charge notre bibliothèque STRONG(libMaCamera.so) fraîchement
   créée. Pour rappel STRONG(scicos_camera_firewire) est la fonction
   de simulation a importée dans Scilab.</p>

<p>Le script STRONG(toto.sci) suivant permet de lancer automatiquement
   la compilation et, si tout va bien, permet de créer une palette
   nommée STRONG(myblock.cosf). On peut utiliser le menu STRONG(Open
   as palette) pour ouvrir et créer une palette valide avec le fichier
   STRONG(myblock.cosf). Ce script est lancé depuis le prompt de
   Scilab.</p>

CODE
// Fichier: toto.sci

// Aller dans le repertoire de vos fichiers sources.
cd /le/chemin/de/ma/biblio/partagee/;

// Compiler fichiers *.sci --> *.bin
genlib('lib_ma_camera', pwd()));

// Creer un fichier Scicos 'Camera.cosf' avec les nouveaux
//  blocs diagrammes
create_palette(pwd());

// Charger les bliotheques *.bin dans Scilab
load lib;

// Charger les librairies paratgees *.so, *.dll dans Scilab
exec loader.sce;
ENDCODE

SUBSECTION(ICON_READ[]Avec la méthode 2 (builder),chargmet2)

<p>L'avantage avec cette méthode est que le fichier STRONG(loader.sce)
   est automatiquement créé par Scilab.</p>

<p>Le script STRONG(toto.sci) suivant permet de lancer automatiquement
   la compilation et, si tout va bien, permet de créer une palette
   nommée STRONG(myblock.cosf). On peut utiliser le menu STRONG(Open
   as palette) pour ouvrir et créer une palette valide avec le fichier
   STRONG(myblock.cosf). Ce script est lancé depuis le prompt de
   Scilab.</p>

CODE
// Fichier: toto.sci

// Aller dans le repertoire de vos fichiers sources.
cd /le/chemin/de/ma/biblio/partagee/;

// Genere automatiquement un Makefile et compile les sources
exec('builder.sce');

// Compiler fichiers *.sci --> *.bin
genlib('lib_ma_camera', pwd());

// Creer un fichier Scicos 'Camera.cosf' avec les nouveaux
//  blocs diagrammes
create_palette(pwd());

// Charger les bliotheques *.bin dans Scilab
load lib;

// Charger les librairies paratgees *.so, *.dll dans Scilab
exec loader.sce;
ENDCODE

<p>La seule différence par rapport à l'autre script est l'appel au
   builder.sce.</p>

SECTION(Utiliser notre nouveau bloc dans une application)

SUBSECTION(ICON_GEAR[]Nouveau projet,nouv)
<p>Créer un nouveau projet. Dans le menu STRONG(Palette), sélectionner
   STRONG(Load as Palette) et chercher le fichier *.cosf qui a été
   généré. Une nouvelle palette doit apparaître dans le menu
   STRONG(Palettes).</p>

<p>Ok, maintenant, on peut ouvrir cette palette de blocs Scicos et
   sélectionner notre nouveau bloc dans notre nouvelle application. Si
   on clique sur ce bloc une fenêtre de dialogue apparaît comme sur la
   figure de droite. Il existe une fonction scilab qui génère
   automatiquement la palette mais je ne sais pas comment
   l'utiliser.</p>

TABLEAU(2,CAPTION(tuto/scicos/camera2.jpg),CAPTION(tuto/scicos/camera1.jpg))

<p>Si tout est correct et si on clique sur le bouton OK de la fenêtre
  de dialogue, Scicos enregistre les nouvelles options. Sinon, il
  affiche un message d'erreur (pas toujours explicite et/ou crash
  ;(. Dans ce cas la, il est probable que vous avez laissé une erreur
  dans la fonction d'interface. Si vous lancez la simulation et que
  Scilab crash c'est dans la fonction de simulation qu'il y a un bogue
  ou que vous avez utilisé la fonction STRONG(exit). En cas de crash,
  il faut nettoyer tous les binaires générés, effacer le bloc concerné
  dans l'application puis tout recompiler. Il se peut que Scicos garde
  en mémoire les fonctions précédentes (*.sci ou *.bin) et ne charge
  pas la nouvelle version. C'est vrai si on n'efface les blocs
  concernés. Relancer tout Scilab au cas où (c'est assez pénible).</p>

CODE
# A lancer dans un shell et dans le bon répertoire

rm -fr lib .??* \#* *~ *.a *.o *.la *.lo *.so loader.sce Makelib  \
       myblock.cosf names *.bin scicos.cosf .libs
ENDCODE

SUBSECTION(ICON_GEAR[]Charger automatiquement mes blibliothèques partagées,scilabstar)

<p>Lancer à la main le script STRONG(toto.sci) de chargement des
   blibliothèques dans Scilab devient contraignant si cette opération
   doit être souvent répétée. Il suffit de coller le code à la toute
   fin du fichier STRONG(scilab.star) qui se trouve à la racine du
   répertoire de Scilab. On peut également ajouter les deux lignes
   suivantes :</p>

CODE
cd /le/chemin/de/mon/programme/scicos/;
scicos le_nom_de_mon_fichier.cos;
ENDCODE

<p>A chaque démarrage de Scilab, les blibliothèques seront chargées,
   scicos se lancera ainsi que votre application.</p>

SUBSECTION(ICON_READ[]Dernières remarques,conclu)

<p>Enfin, dernière remarque : surtout ne faites jamais de boucle
  infinie dans la fonction de simulation car la simulation part, elle
  aussi, en boucle infinie et gèle l'IHM. Il ne faut surtout pas
  croire que Scicos joue le rôle d'un ordonnanceur de tâches et préempte chaque
  fonction de simulation. Ce n'est pas son rôle. Par contre, je n'ai
  pas essayé de mettre plusieurs threads pour une même fonction mais
  je pense que ça peut marcher. De même je n'ai pas essayer de faire
  tourner une petite IHM (Tcl/Tk voir pourquoi pas Gtk) dans Scicos,
  il faut voir du côté d'
  EXTLINK(http://www.scicos.fr/examples.html,ici) pour plus
  d'infos.</p>

END_BODY(,,,,) dnl END_BODY(,tuto_syndex)
